/*
 * nls.h - Definitions for Native Language Support
 *
 * For use with compiled-in resources generated by nlstool
 *
 * Copyright (C) 2025 Thorsten Otto
 */
#ifndef _LIBNLS_H
#define _LIBNLS_H 1

#include <locale.h>
#if (defined __APPLE__ && defined __MACH__)
# include <xlocale.h>
#endif

typedef unsigned short nls_key_offset;

/*
 * Possible plural forms supported
 */
enum {
	PLURAL_NONE,        /* nplurals=1; plural=0; ja, ko, zh */
	PLURAL_NOT_ONE,     /* nplurals=2; plural=n != 1; (most common) */
	PLURAL_GREATER_ONE, /* nplurals=2; plural=(n > 1); fr, pt_BR */
	PLURAL_RULE_3,      /* nplurals=2; plural=(n%10!=1 || n%100==11); is */
	PLURAL_RULE_4,      /* nplurals=2; plural=(n != 0); jv */
	PLURAL_RULE_5,      /* nplurals=2; plural=n%10==1 ? 0 : 1; mk */
	PLURAL_RULE_6,      /* nplurals=2; plural=(n==1 || n==2 || n==3 || (n%10!=4 && n%10!=6 && n%10!=9)); tl */
	PLURAL_RULE_7,      /* nplurals=2; plural=(n<=1 || (n>=11 && n<=99)); tzm */
	PLURAL_RULE_8,      /* nplurals=3; plural=(n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2; cs, sk */
	PLURAL_RULE_9,      /* nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); bs, hr, sh, sr */
	PLURAL_RULE_10,     /* nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n != 0 ? 1 : 2); lv */
	PLURAL_RULE_11,     /* nplurals=3; plural=(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); pl */
	PLURAL_RULE_12,     /* nplurals=3; plural=n==1 ? 0 : (n==0 || (n%100 > 0 && n%100 < 20)) ? 1 : 2; ro */
	PLURAL_RULE_13,     /* nplurals=3; plural=(n==1) ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2; csb */
	PLURAL_RULE_14,     /* nplurals=3; plural=n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2; me */
	PLURAL_RULE_15,     /* nplurals=3; plural=(n==0 ? 0 : n==1 ? 1 : 2); cv, iu */
	PLURAL_RULE_16,     /* nplurals=3; plural=n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>=14) ? 1 : 2; be, ru, uk */
	PLURAL_RULE_17,     /* nplurals=3; plural=(n%10==0 || (n%100>=11 && n%100<=19) ? 0 : n%10==1 && n%100!=11 ? 1 : 2); prg */
	PLURAL_RULE_18,     /* nplurals=3; plural=(n==0 || n==1 ? 0 : n>=2 && n<=10 ? 1 : 2); shi */
	PLURAL_RULE_19,     /* nplurals=4; plural=(n==1 ? 0 : n%10>=2 && (n%100<10 || n%100>=20) ? 1 : n%10==0 || (n%100>10 && n%100<20) ? 2 : 3); lt */
	PLURAL_RULE_20,     /* nplurals=4; plural=(n%100==1 ? 0 : n%100==2 ? 1 : n%100==3 || n%100==4 ? 2 : 3); sl */
	PLURAL_RULE_21,     /* nplurals=4; plural=(n==1) ? 0 : (n==2) ? 1 : (n != 8 && n != 11) ? 2 : 3; cy */
	PLURAL_RULE_22,     /* nplurals=4; plural=(n==1 || n==11) ? 0 : (n==2 || n==12) ? 1 : (n > 2 && n < 20) ? 2 : 3; gd */
	PLURAL_RULE_23,     /* nplurals=4; plural=(n==1) ? 0 : (n==2) ? 1 : (n == 3) ? 2 : 3; kw */
	PLURAL_RULE_24,     /* nplurals=4; plural=(n==1 ? 0 : n==0 || ( n%100>1 && n%100<11) ? 1 : (n%100>10 && n%100<20 ) ? 2 : 3); mt */
	PLURAL_RULE_25,     /* nplurals=4; plural=(n%10==1 ? 0 : n%10==2 ? 1 : n%100==0 || n%100==20 || n%100==40 || n%100==60 || n%100==80 ? 2 : 3); gv */
	PLURAL_RULE_26,     /* nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n < 11 ? 3 : 4; ga */
	PLURAL_RULE_27,     /* nplurals=5; plural=(n%10==1 && n%100!=11 && n%100!=71 && n%100!=91 ? 0 : n%10==2 && n%100!=12 && n%100!=72 && n%100!=92 ? 1 : ((n%10>=3 && n%10<=4) || n%10==9) && (n%100<10 || n%100>19) && (n%100<70 || n%100>79) && (n%100<90 || n%100>99) ? 2 : n!=0 && n%1000000==0 ? 3 : 4); br */
	PLURAL_RULE_28,     /* nplurals=6; plural=(n==0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 : n%100>=11 ? 4 : 5); ar */
	PLURAL_RULE_29,     /* nplurals=6; plural=(n==0 ? 0 : n==1 ? 1 : n==2 ? 2 : n==3 ? 3 : n==6 ? 4 : 5); cy? */
};

#define ISO639_CODE_LEN 5

typedef struct _libnls_translation {
	int tos_country_code;
	char lang_id[ISO639_CODE_LEN + 1];
	int plural_form;
	const char *translations;
	const nls_key_offset *offsets;
} libnls_translation;

typedef struct _libnls_domain {
	const char *package;
	const char *keys;
	const libnls_translation *languages;
	libnls_translation current_translation;
} libnls_domain;

/* The LC_MESSAGES locale category is the category used by the functions
   gettext() and dgettext().  It is specified in POSIX, but not in ANSI C.
   On systems that don't define it, use an arbitrary value instead. */
#if !defined LC_MESSAGES
# define LC_MESSAGES 1729
#endif

/* Resolve a platform specific conflict on DJGPP.  GNU gettext takes
   precedence over _conio_gettext.  */
#ifdef __DJGPP__
# undef gettext
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef unsigned int libnls_msgid_type;

/* Redirect the functions to those prefixed with "libnls_". */

/* Look up MSGID in the current default message catalog for the current
   LC_MESSAGES locale.  If not found, returns MSGID itself (the default
   text).  */
const char *libnls_gettext(libnls_msgid_type __msgid);
#define gettext(__msgid) libnls_gettext((libnls_msgid_type)(size_t)(__msgid))

/* Look up MSGID in the DOMAINNAME message catalog for the current
   LC_MESSAGES locale.  */
const char *libnls_dgettext(const char *__domainname, libnls_msgid_type __msgid);
#define dgettext(__domainname, __msgid) libnls_dgettext(__domainname, (libnls_msgid_type)(size_t)(__msgid))

/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
   locale.  */
const char *libnls_dcgettext(const char *__domainname, libnls_msgid_type __msgid, int __category);
#define dcgettext(__domainname, __msgid, __category) libnls_dcgettext(__domainname, (libnls_msgid_type)(size_t)(__msgid), __category)

/* Similar to 'gettext' but select the plural form corresponding to the
   number N.  */
const char *libnls_ngettext(libnls_msgid_type __msgid1, libnls_msgid_type __msgid2, unsigned long int __n);
#define ngettext(__msgid1, __msgid2, __n) libnls_ngettext((libnls_msgid_type)(size_t)(__msgid1), (libnls_msgid_type)(size_t)(__msgid2), __n)


/* Similar to 'dgettext' but select the plural form corresponding to the
   number N.  */
const char *libnls_dngettext(const char *__domainname, libnls_msgid_type __msgid1, libnls_msgid_type __msgid2, unsigned long int __n);
#define dngettext(__domainname, __msgid1, __msgid2, __n) libnls_dngettext(__domainname, (libnls_msgid_type)(size_t)(__msgid1), (libnls_msgid_type)(size_t)(__msgid2), __n)

/* Similar to 'dcgettext' but select the plural form corresponding to the
   number N.  */
const char *libnls_dcngettext(const char *__domainname, libnls_msgid_type __msgid1, libnls_msgid_type __msgid2, unsigned long int __n, int __category);
#define dcngettext(__domainname, __msgid1, __msgid2, __n, __category) libnls_dcngettext(__domainname, (libnls_msgid_type)(size_t)(__msgid1), (libnls_msgid_type)(size_t)(__msgid2), __n, __category)


/* Set the current default message catalog to DOMAINNAME.
   If DOMAINNAME is null, return the current default.
   If DOMAINNAME is "", reset to the default of "messages".  */
const char *libnls_textdomain(const char *__domainname);
#define textdomain(__domainname) libnls_textdomain(__domainname)

/* Specify that the DOMAINNAME message catalog will be found
   in DIRNAME rather than in the system locale data base.  */
const char *libnls_bindtextdomain(const char *__domainname, const char *__dirname, libnls_domain *__domain);
#define __libnls_cat_(a, b) a ## b
#define __libnls_cat(a, b) __libnls_cat_(a, b)
#define bindtextdomain(__domainname, __dirname) libnls_bindtextdomain(__domainname, __dirname, &__libnls_cat(GETTEXT_PACKAGE, _domain))

/* Specify the character encoding in which the messages from the
   DOMAINNAME message catalog will be returned.  */
const char *libnls_bind_textdomain_codeset(const char *__domainname, const char *__codeset);
#define bind_textdomain_codeset(__domainname, __codeset) libnls_bind_textdomain_codeset(__domainname, __codeset)


/* Support for the locale chosen by the user.  */
char *libnls_setlocale(int __category, const char *__locale);
#define setlocale(__category, __locale) libnls_setlocale(__category, __locale)

#ifdef __cplusplus
}
#endif

#endif /* _LIBNLS_H */
