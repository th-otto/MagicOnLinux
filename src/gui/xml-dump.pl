#!/usr/bin/perl -w 

#
#  XML Message Extractor
#
#  Copyright (C) 2025 Thorsten Otto
#
#

## Loaded modules
use strict; 
use Data::Dumper;

my $me = "xml-dump.pl";

my $FILE;

my $input;
my $last_section;
my $last_choice;
my @sections;

## Always print first
$| = 1;

my $OUT;
open $OUT, ">>", "/dev/stdout";
# binmode (OUT) if $^O eq 'MSWin32';

while (@ARGV > 0)
{
	$FILE = $ARGV[0];
	&convert;
	shift @ARGV;
}
&msg_write;
# close OUT;


sub convert
{
	## Reading the file
	{
		local(*IN);
		local $/; #slurp mode
		open(IN, "<$FILE") || die "can't open $FILE: $!";
		binmode(IN);
		$input = <IN>;
		close IN;
	}

	### For generic translatable XML files ###
	my $tree = readXml($input);
}

sub escape_char
{
	return '\"' if $_ eq '"';
	return '\n' if $_ eq "\n";
	return '\\\\' if $_ eq '\\';

	return $_;
}

sub escape($)
{
	my ($string) = @_;
	return join "", map &escape_char, split //, $string;
}

sub tree_comment
{
	my $expat = shift;
	my $data = $expat->original_string();
	my $clist = $expat->{Curlist};
	my $pos = $#$clist;

	$data =~ s/^<!--//s;
	$data =~ s/-->$//s;
	# push @$clist, 1 => $data;
}

sub tree_cdatastart
{
	my $expat = shift;
	my $clist = $expat->{Curlist};
	my $pos = $#$clist;

	push @$clist, 0 => $expat->original_string();
}

sub tree_cdataend
{
	my $expat = shift;
	my $clist = $expat->{Curlist};
	my $pos = $#$clist;

	$clist->[$pos] .= $expat->original_string();
}

sub tree_char
{
	my $expat = shift;
	my $text = shift;
	my $clist = $expat->{Curlist};
	my $pos = $#$clist;

	# Use original_string so that we retain escaped entities
	# in CDATA sections.
	#
	if ($pos > 0 and $clist->[$pos - 1] eq '0')
	{
		$clist->[$pos] .= $expat->original_string();
	} else
	{
		push @$clist, 0 => $expat->original_string();
	}
}

sub tree_start
{
	my $expat = shift;
	my $tag = shift;
	my $lineno = $expat->current_line() + 1;
	my $msgctxt = "";
	my %tree = ();
	my $name;

	while (my $attr = shift)
	{
		my $value = shift;
		if ($attr eq "msgctxt")
		{
			$msgctxt = "$value\004";
		}
		if ($attr =~ /^_/)
		{
			$value = "$msgctxt$value";
		}
		$tree{$attr} = "$value";
	}
	$name = $tree{'name'};
	if ($tag eq 'preferences')
	{
		# ignore
	} elsif ($tag eq 'section')
	{
		die if (defined($last_section));
		die if (!defined($tree{'name'}));
		$tree{'widgets'} = [];
		push @sections, \%tree;
		$tree{'scrolled'} = "0" if (!defined($tree{'scrolled'}));
		$last_section = \$tree{'widgets'};
	} elsif ($tag eq 'path' || $tag eq 'folder' || $tag eq 'string' || $tag eq 'int' || $tag eq 'bool' || $tag eq 'choice')
	{
		die if (!defined($last_section));
		die if (!defined($tree{'name'}));
		$tree{'type'} = $tag;
		
		$tree{'flags'} = 'NO_FLAGS' if (!defined($tree{'flags'}));
		$tree{'gui'} = 0 if (!defined($tree{'gui'}));
		push @$$last_section, \%tree;
		if ($tag eq 'choice')
		{
			$tree{'choices'} = [];
			die if (defined($last_choice));
			$last_choice = \$tree{'choices'};
		}
		if ($tag eq 'int')
		{
			$tree{'minval'} = 0 if (!defined($tree{'minval'}));
			# INT_MAX, because LONG_MAX might not be representable in a double
			$tree{'maxval'} = 2147483647 if (!defined($tree{'maxval'}));
			$tree{'step'} = 1 if (!defined($tree{'step'}));
		}
	} elsif ($tag eq 'select')
	{
		die if (!defined($last_section));
		die if (!defined($last_choice));
		if (!defined($tree{'value'}))
		{
			$tree{'value'} = @$$last_choice + 1;
		}
		push @$$last_choice, \%tree;
	} else
	{
		print STDERR "unsupported element $tag\n";
	}
}

sub tree_end
{
	my $expat = shift;
	my $tag = shift;
	my $lineno = $expat->current_line() + 1;
	if ($tag eq 'preferences')
	{
		die if (defined($last_section));
	} elsif ($tag eq 'section')
	{
		die if (!defined($last_section));
		undef $last_section;
	} elsif ($tag eq 'choice')
	{
		die if (!defined($last_choice));
		undef $last_choice;
	}
}

sub readXml
{
	my $xmldoc = shift || return;
	my $ret = eval 'require XML::Parser';
	if (!$ret)
	{
		die "You must have XML::Parser installed to run $0\n\n";
	}
	my $xp = new XML::Parser(Style => 'Tree');
	$xp->setHandlers(Char => \&tree_char);
	$xp->setHandlers(Start => \&tree_start);
	$xp->setHandlers(End => \&tree_end);
	$xp->setHandlers(CdataStart => \&tree_cdatastart);
	$xp->setHandlers(CdataEnd => \&tree_cdataend);

	$xp->setHandlers(Comment => \&tree_comment);

	my $tree = $xp->parse($xmldoc);

	return $tree;
}

sub print_msg($)
{
	my ($string) = @_;
	my @lines = split (/\n/, $string, -1);
	for (my $n = 0; $n < @lines; $n++)
	{
		print $OUT "\""; 
		print $OUT escape($lines[$n]);
		print $OUT "\"\n"; 
	}
}

sub msg_write
{
	my $filename = $FILE;

print << "EOF";
/*
 * generated by $me -- DO NOT EDIT --
 */
enum {
	TYPE_NONE,
	TYPE_PATH,				/* path only, eg. the name of the config file */
	TYPE_FOLDER,			/* folder only, eg. the rootfs folder */
	TYPE_FOLDER_OR_PATH,	/* folder or path, eg. an XFS mount directory or volume image */
	TYPE_STRING,
	TYPE_INT,
	TYPE_UINT,
	TYPE_BOOL,
	TYPE_CHOICE
};

typedef struct {
	const char *label;
	const char *value;
	const char *icon_name;
} xml_widget_choice;

typedef struct {
	int type;
	const char *name;
	const char *label;
	const char *tooltip;
	int gui_only;
	union {
		struct {
			const char *default_value;
			int flags;
		} path;
		struct {
			const char *default_value;
		} string;
		struct {
			int default_value;
		} boolvalue;
		struct {
			long default_value;
			long minval;
			long maxval;
			long step;
		} integer;
		struct {
			const char *default_value;
			int num_choices;
			const xml_widget_choice *choices;
		} choice;
	} u;
} xml_widget;

typedef struct {
	const char *name;
	const char *label;
	const char *desc;
	const char *icon_name;
	int scrolled;
	const xml_widget *widgets;
} xml_section;

#define NO_FLAGS -1
#define DRV_FLAG_RDONLY         1   /* read-only */
#define DRV_FLAG_8p3            2   /* filenames in 8+3 format, uppercase */
#define DRV_FLAG_CASE_INSENS    4   /* case insensitive, e.g. (V)FAT or HFS(+) */

#ifndef N_
#define N_(x) x
#endif
#ifndef NULL
#define NULL 0
#endif

EOF
	# print Dumper(@sections);
	# dump the choices first, so we can reference them later
	foreach my $section (@sections)
	{
		my $section_name = "section_" . lc($section->{'name'});
		$section_name =~ tr/ /_/;
		# printf "section %s\n", $section_name;
		my $widgets = $section->{'widgets'};
		foreach my $widget (@$widgets)
		{
			if ($widget->{'type'} eq 'choice')
			{
				my $widget_name = "widget_" . lc($widget->{'name'}) . "_choices";
				printf $OUT "static xml_widget_choice const %s[] = {\n", $widget_name;
				my $choices = $widget->{'choices'};
				foreach my $choice (@$choices)
				{
					my $icon;

					if (defined($choice->{'icon'}))
					{
						$icon = '"' . escape($choice->{'icon'}) . '"';
					} else
					{
						$icon = "NULL";
					}
					printf $OUT "\t{ N_(\"%s\"), \"%s\", %s },\n", escape($choice->{'_label'}), $choice->{'value'}, $icon;
				}
				print $OUT "\t{ NULL, NULL, NULL }\n};\n\n";
			}
		}
	}

	foreach my $section (@sections)
	{
		my $section_name = "section_" . lc($section->{'name'});
		$section_name =~ tr/ /_/;
		# printf "section %s\n", $section_name;
		printf $OUT "static xml_widget const %s_widgets[] = {\n", $section_name;
		my $widgets = $section->{'widgets'};
		foreach my $widget (@$widgets)
		{
			my $name;
			my $tooltip;
			my $default_value;
			my $label;

			$name = '"' . escape($widget->{'name'}) . '"';
			$label = 'N_("' . escape($widget->{'_label'}) . '")';

			if (defined($widget->{'_tooltip'}))
			{
				# $tooltip = 'N_("' . escape($widget->{'_tooltip'}) . '")';
				$tooltip = 'N_("' . $widget->{'_tooltip'} . '")';
			} else
			{
				$tooltip = "0";
			}
			if (defined($widget->{'default'}))
			{
				# $default_value = '"' . escape($widget->{'default'}) . '"';
				$default_value = '"' . $widget->{'default'} . '"';
			} else
			{
				$default_value = "NULL";
			}
			# printf "%s %s\n", $widget->{'type'}, $widget->{'name'};
			if ($widget->{'type'} eq 'path')
			{
				printf $OUT "\t{ TYPE_PATH, %s,\n", $name;
				printf $OUT "\t  .label = %s,\n", $label;
				printf $OUT "\t  .tooltip = %s,\n", $tooltip;
				printf $OUT "\t  .gui_only = %d,\n", $widget->{'gui'};
				printf $OUT "\t  { .path = {\n";
				printf $OUT "\t    .default_value = %s,\n", $default_value;
				printf $OUT "\t    .flags = %s } } },\n", $widget->{'flags'};
			} elsif ($widget->{'type'} eq 'folder')
			{
				printf $OUT "\t{ TYPE_FOLDER, %s,\n", $name;
				printf $OUT "\t  .label = %s,\n", $label;
				printf $OUT "\t  .tooltip = %s,\n", $tooltip;
				printf $OUT "\t  .gui_only = %d,\n", $widget->{'gui'};
				printf $OUT "\t  { .path = {\n";
				printf $OUT "\t    .default_value = %s,\n", $default_value;
				printf $OUT "\t    .flags = %s } } },\n", $widget->{'flags'};
			} elsif ($widget->{'type'} eq 'pathfolder')
			{
				printf $OUT "\t{ TYPE_FOLDER_OR_PATH, %s,\n", $name;
				printf $OUT "\t  .label = %s,\n", $label;
				printf $OUT "\t  .tooltip = %s,\n", $tooltip;
				printf $OUT "\t  .gui_only = %d,\n", $widget->{'gui'};
				printf $OUT "\t  { .path = {\n";
				printf $OUT "\t    .default_value = %s,\n", $default_value;
				printf $OUT "\t    .flags = %s } } },\n", $widget->{'flags'};
			} elsif ($widget->{'type'} eq 'string')
			{
				printf $OUT "\t{ TYPE_STRING, %s,\n", $name;
				printf $OUT "\t  .label = %s,\n", $label;
				printf $OUT "\t  .tooltip = %s,\n", $tooltip;
				printf $OUT "\t  .gui_only = %d,\n", $widget->{'gui'};
				printf $OUT "\t  { .string = {\n";
				printf $OUT "\t    .default_value = %s } } },\n", $default_value;
			} elsif ($widget->{'type'} eq 'int')
			{
				my $type;
				# some values must be written as unsigned, or the application fails to parse them
				if ($widget->{'name'} =~ m/app_window_.*/)
				{
					$type = 'TYPE_UINT';
				} else
				{
					$type = 'TYPE_INT';
				}
				printf $OUT "\t{ %s, %s,\n", $type, $name;
				printf $OUT "\t  .label = %s,\n", $label;
				printf $OUT "\t  .tooltip = %s,\n", $tooltip;
				printf $OUT "\t  .gui_only = %d,\n", $widget->{'gui'};
				printf $OUT "\t  { .integer = {\n";
				printf $OUT "\t    .default_value = %d,\n", defined($widget->{'default'}) ? $widget->{'default'} : 0;
				printf $OUT "\t    .minval = %d,\n", $widget->{'minval'};
				printf $OUT "\t    .maxval = %d,\n", $widget->{'maxval'};
				printf $OUT "\t    .step = %d } } },\n", $widget->{'step'};
			} elsif ($widget->{'type'} eq 'bool')
			{
				printf $OUT "\t{ TYPE_BOOL, %s,\n", $name;
				printf $OUT "\t  .label = %s,\n", $label;
				printf $OUT "\t  .tooltip = %s,\n", $tooltip;
				printf $OUT "\t  .gui_only = %d,\n", $widget->{'gui'};
				printf $OUT "\t  { .boolvalue = {\n";
				printf $OUT "\t    .default_value = %d } } },\n", defined($widget->{'default'}) ? $widget->{'default'} : 0;
			} elsif ($widget->{'type'} eq 'choice')
			{
				my $choices = $widget->{'choices'};
				$widget->{'minval'} = 0;
				$widget->{'maxval'} = @$choices;
				printf $OUT "\t{ TYPE_CHOICE, %s,\n", $name;
				printf $OUT "\t  .label = %s,\n", $label;
				printf $OUT "\t  .tooltip = %s,\n", $tooltip;
				printf $OUT "\t  .gui_only = %d,\n", $widget->{'gui'};
				printf $OUT "\t  { .choice = {\n";
				printf $OUT "\t\t.default_value = %s,\n", defined($widget->{'default'}) ? ('"' . $widget->{'default'} . '"') : "NULL";
				printf $OUT "\t\t.num_choices = sizeof(widget_%s_choices) / sizeof(widget_%s_choices[0]) - 1,\n", $widget->{'name'}, $widget->{'name'};
				printf $OUT "\t\t.choices = widget_%s_choices } } },\n", $widget->{'name'};
			} else
			{
				die;
			}
		}
		print $OUT "\t{ TYPE_NONE, NULL, NULL, NULL, 0, { .string = { NULL } } }\n};\n\n";
	}

	printf $OUT "static xml_section const xml_sections[] = {\n";
	foreach my $section (@sections)
	{
		my $icon;
		my $desc;

		if (defined($section->{'icon'}))
		{
			$icon = '"' . $section->{'icon'} . '"';
		} else
		{
			$icon = "NULL";
		}
		if (defined($section->{'_desc'}))
		{
			$desc = 'N_("' . $section->{'_desc'} . '")';
		} else
		{
			$desc = "0";
		}
		my $section_name = "section_" . lc($section->{'name'});
		$section_name =~ tr/ /_/;
		printf $OUT "\t{\n";
		printf $OUT "\t\t.name = \"%s\",\n", $section->{'name'};
		printf $OUT "\t\t.label = N_(\"%s\"),\n", $section->{'_label'};
		printf $OUT "\t\t.desc = %s,\n", $desc;
		printf $OUT "\t\t.icon_name = %s,\n", $icon;
		printf $OUT "\t\t.scrolled = %d,\n", $section->{'scrolled'};
		printf $OUT "\t\t.widgets = %s_widgets\n", $section_name;
		printf $OUT "\t},\n";
	}
	print $OUT "};\n\n";
}
