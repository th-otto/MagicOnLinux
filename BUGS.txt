Bei Copy/Paste verschwinden die Leerzeichen

Wenn auf der Kommandozeile die Schalter -c und -e angegeben sind, dann die richtige Datei editieren!

640x400x2ip crashes
640x200x2ip crashes
16-colour mode (packed-pixel) works
256-colour mode works
32k-colour mode works
problem with palette?

(23:28:38) DBG-INF LoadReloc() - Memory size Atari = 0x00800000 (= 8192 kBytes)
(23:28:38) DBG-INF LoadReloc() - Load address of system (TEXT) = 0x007c9c68 (68k)


Der Absturz passiert bei PDkill.
Der Parameter in a0 ist 0x007cb456 und zeigt in den ROM-Code. Eigentlich sollte es eine Basepage sein.

Der Aufruf kommt von XEXE_TERM. Register a0 kommt von 6(a4) und ist 0x007cb456, was falsch ist.
Stattdessen sollte 6(a4) ein PD sein.

Der Unterschied im Verhalten von defektem Farbmodus und SW-Modus beginnt in dem Moment,
in dem er bei Farbe nach pc = 0x007e8156 (OS ROM 0x0001e4ee) springt. Das ist pgml_term.
Das kommt von pgm_loader.
Eigentlich sollte er gar nicht nach pgml_term kommen, da ist dann etwas schiefgelaufen.

0x7cb456 ist ROM-Adresse 0x17ee. Das ist in MAGXBIOS.S, print_bombs10. Da wäre ein übler Fehler.

Beim ersten Sprung nach pgm_loader geht etwas schief, und er springt nach print_bombs10.
Im Monochrom-Modus dagegen läuft er weiter.

Im Monochrom-Modus liegen auf dem Stack von pgm_loader:
Vielleicht ist die Ausgabe des Stacks falsch?
Falscher stackpointer?

  (sp) = 0x4b524f4d        <<<== seltsam: KROM, das ist der mcb_magic für den letzten Block
 4(sp) = 0x007948a0         Das ist unterhalb des OS, also irgendwo im RAM
 d0 = 0x00000000
 d1 = 0x00000000
 d2 = 0x00000000
 d3 = 0x00000000
 d4 = 0x00000000
 d5 = 0x00000000
 d6 = 0x00000000
 d7 = 0x00000000
 a0 = 0x00000000
 a1 = 0x00000000
 a2 = 0x00000000
 a3 = 0x00000000
 a4 = 0x00000000
 a5 = 0x00000000
 a6 = 0x00000000
 a7 = 0x00035268
 usp = 0x00000000

Im ip-Modus:
  (sp) = 0x007cb456        <<<== seltsam
 4(sp) = 0x007cb456        <<<== seltsam
 d0 = 0x007cb996
 d1 = 0x007cb456
 d2 = 0x007e1072
 d3 = 0x007c9e78
 d4 = 0x007cb456
 d5 = 0x007cb456
 d6 = 0x007cb456
 d7 = 0x007cb014
 a0 = 0x007cb456
 a1 = 0x007cb456
 a2 = 0x007cb456
 a3 = 0x007cb456
 a4 = 0x007cb456
 a5 = 0x007cb456
 a6 = 0x007cb456
 a7 = 0x00000044        <<<== seltsam
 usp = 0x00080000

Bei PC = 0x7e7f5a (OS 0x1e2f2) kriegt a7 den Wert 0x44.
die vorherigen PC-Werte sind:
 PC was 0x007e8af0 (OS rel 0x01ee88)    bei AESEVT.S label ad_return
 PC was 0x007e8aec (OS rel 0x01ee84)
 PC was 0x007e8ae2 (OS rel 0x01ee7a)
 ..
 Wir testen auf sp < 0x100, und das passiert bei pc = 7e8ab0. Vorherige Werte
 PC was 0x007e8aae (OS rel 0x01ee46)    movea.l  (a1)+,sp
 PC was 0x007e8aaa (OS rel 0x01ee42)    lea      $58c(a0),a1
 PC was 0x007e8aa6 (OS rel 0x01ee3e)    move.w   $259c(a0),d0

a3 ist 0xbff8, wohl der alte Kontext vor dem Wechsel
a0 ist 0xe5a4, das ist wohl der neue Kontext.
Ob der Kontext dieser APP beschädigt wurde?
Der gerettete ssp liegt bei offset 0x58c in der APP-Struktur.
Nein, der Kontext ist offenbar nicht beschädigt worden, sondern
das ssd-Feld ist nie beschrieben worden. Das läßt sich anhand
der Schreibzugriffe in m68k_write_memory_32() feststellen.
Eine Gegenprobe zeigt, daß Adresse 0xbff8 + 0x58c wie erwartet
beschrieben wurde, mit den erwarteten Werten.

Die Frage ist also: Warum wurde das Feld ssp nie beschrieben?
Doch, es gibt es write.8, mglw. beim Löschen des Speichers.

Laß mal schauen, wann und wo das Feld ap_pd geschrieben wird:
Der Wert 0x25ce0 wird geschrieben bei pc = 0x7e3a9c (ROM OS 0x19e34).
Das ist bei init_APPL in AESMAIN.S.
a5 ist die APP-Struktur und hat den Wert 0xe5a4. Das ist korrekt.
d0 hat den Wert 0, das müßte die Stacklänge sein. Aber warum
ist die Null?

init_appl wird zweimal aufgerufen bei aes_start, das erste
ist das AES, hat einen leeren Namen und keinen Stack.
An Adresse 0x122c ist sust_len, die Stack-Größe für alle
neuen Threads. Die ist aber Null. Warum?

sust_len wird zunächst mit 0 initialisiert, bei PC = 0x7c9ee2.
Bei PC = 0x7ca208 wird 0x2000 reingeschrieben.
Bei PC = 0x7e16ec wird 0 ins erste 16-Bit-Halbwort geschrieben.
Dann nochmal. Das ist bei PC = OS ROM 0x17a84.
Das ist draw_spr in LINEA.S und gehört zum VDI.
Der Befehl, der den Speicher überschreibt, ist
move.w   d2,(a2)
    d0 = 0xfffc1fff
    d1 = 0x1c000
    d2 = 0
    d3 = 4
    a0 = 0x1d32
    a1 = 0x80400c
    a2 = 0x122c !!  sollte der "sprite save buffer" sein.

draw_sprite kriegt in Register a2 den Hintergrundpuffer.
Das scheint direkt der Befehl A00D zu sein.
in OSBIND.INC: A_DRAW_SPRITE

Die VDI-Treiber MFA32K.S, MFM2.S, MFM16.S, MFM16M.S, MFM32K.S, MFM256.S
kennen Draw Sprite ($A00D).

Die VDI-Treiber MFM16IP.S und MFM4IP.S kennen die anscheinend nicht.

Was ist mit der Maus? Wer malt die? Wer ruft LineA a00d auf?
Wer gibt einen falschen Puffer an?


alter Kontext, a3
 ap = 0x0000bff8
 ap_id = 0
 ap_type = 0
 ap_dummy1 =
 ap_status = 0
 ap_cmd =
 ap_tai =
 ap_ssp = 0x0000e4be
 ap_pd = 0x0001db64
 ap_etvterm = 0x007cafb2
 ap_stkchk = 0x416e4b72

neuer Kontext, a0
 ap = 0x0000e5a4
 ap_id = 2
 ap_type = 0
 ap_dummy1 =   COPS
 ap_status = 0
 ap_cmd = C:\AUTO\ACCS\COPS.ACC
 ap_tai =
 ap_ssp = 0x00000000        <<<< SELTSAM
 ap_pd = 0x00025ce0
 ap_etvterm = 0x007cafb2
 ap_stkchk = 0x416e4b72


Vor ap_ssp liegen:
    UINT16_BE  ap_svd_mouse[37];    // x/y/planes/bg/fg/msk[32]/moff_cnt
    UINT16_BE  ap_prv_mouse[37];
    UINT16_BE  ap_act_mouse[37];

Ob das ein Mauszeiger ist? Ob es da einen Überlauf geben könnte?
Wir gucken direkt auf draw_spr.


68k breakpoint reached
pc = 0x007e16de (OS ROM 0x00017a76)
  (sp) = 0x007e16aa
 4(sp) = 0x00001d22
 d0 = 0x00000008
 d1 = 0x00000062
 d2 = 0x00000000
 d3 = 0x00000004
 d4 = 0x000000a0
 d5 = 0x0000000f
 d6 = 0x00000002
 d7 = 0x00000001
 a0 = 0x00001d22
 a1 = 0x00803d8c
 a2 = 0x00001208    // Hier will er reinschreiben. Was ist 0x1208? Irgendwo in Bconoutvec.
 a3 = 0x007e1738
 a4 = 0x007e1766
 a5 = 0x007e16f0
 a6 = 0x007e16de
 a7 = 0x0000e49a
 usp = 0x00000000

pc = 0x007e16de (OS ROM 0x00017a76)
  (sp) = 0x007e16aa
 4(sp) = 0x00001d22

 PC was 0x007e16a8 (OS rel 0x017a40)
 PC was 0x007e16a4 (OS rel 0x017a3c)
 PC was 0x007e16a2 (OS rel 0x017a3a)
 PC was 0x007e169e (OS rel 0x017a36)
 PC was 0x007e169c (OS rel 0x017a34)
 PC was 0x007e169a (OS rel 0x017a32)
 PC was 0x007e1696 (OS rel 0x017a2e)
 PC was 0x007e1694 (OS rel 0x017a2c)
 PC was 0x007e1690 (OS rel 0x017a28)
 PC was 0x007e168e (OS rel 0x017a26)
 PC was 0x007e16b4 (OS rel 0x017a4c)
 PC was 0x007e1672 (OS rel 0x017a0a)
 PC was 0x007e1670 (OS rel 0x017a08)
 PC was 0x007e166c (OS rel 0x017a04)
 PC was 0x007e1666 (OS rel 0x0179fe)
 PC was 0x007e1660 (OS rel 0x0179f8)
 PC was 0x007e165e (OS rel 0x0179f6)
 PC was 0x007e165c (OS rel 0x0179f4)
 PC was 0x007e1646 (OS rel 0x0179de)
 PC was 0x007e1640 (OS rel 0x0179d8)
 PC was 0x007e163c (OS rel 0x0179d4)
 PC was 0x007e163a (OS rel 0x0179d2)
 PC was 0x007e1638 (OS rel 0x0179d0)
 PC was 0x007e1636 (OS rel 0x0179ce)
 PC was 0x007e1632 (OS rel 0x0179ca)
 PC was 0x007e162e (OS rel 0x0179c6)
 PC was 0x007e162a (OS rel 0x0179c2)
 PC was 0x007e1628 (OS rel 0x0179c0)
 PC was 0x007e1624 (OS rel 0x0179bc)
 PC was 0x007e1620 (OS rel 0x0179b8)
 PC was 0x007e161e (OS rel 0x0179b6)
 PC was 0x007e161a (OS rel 0x0179b2)


Das ist Breakpoint draw_sprite (LINEA.S)

68k breakpoint reached
pc = 0x007e15a2 (OS ROM 0x0001793a)
  (sp) = 0x007dc9a4
 4(sp) = 0x0000332a
 d0 = 0x0000013f
 d1 = 0x00000063
 d2 = 0x00002004
 d3 = 0x00000000
 d4 = 0x00000000
 d5 = 0x00000000
 d6 = 0x00000000
 d7 = 0x00000000
 a0 = 0x00001d18
 a1 = 0x00003356
 a2 = 0x00001200    // hier ist die problematische Puffer-Adresse.
 a3 = 0x00000000
 a4 = 0x00000000
 a5 = 0x0001db64
 a6 = 0x0001001c
 a7 = 0x0000e4b6
 usp = 0x00000000

pc = 0x007e15a2 (OS ROM 0x0001793a)
  (sp) = 0x007dc9a4
 4(sp) = 0x0000332a

 PC was 0x007dc9a0 (OS rel 0x012d38)        // hier kommen wir her, aus v_show_c (INPUT.S)
 PC was 0x007dc99c (OS rel 0x012d34)
 PC was 0x007dc998 (OS rel 0x012d30)
 PC was 0x007dc996 (OS rel 0x012d2e)
 PC was 0x007dc992 (OS rel 0x012d2a)
 PC was 0x007dc98c (OS rel 0x012d24)
 PC was 0x007dc988 (OS rel 0x012d20)
 PC was 0x007dc986 (OS rel 0x012d1e)
 PC was 0x007dc982 (OS rel 0x012d1a)
 PC was 0x007dc980 (OS rel 0x012d18)
 PC was 0x007dc97e (OS rel 0x012d16)
 PC was 0x007dc978 (OS rel 0x012d10)
 PC was 0x007dc972 (OS rel 0x012d0a)
 PC was 0x007dc970 (OS rel 0x012d08)
 PC was 0x007dc96c (OS rel 0x012d04)
 PC was 0x007dc96a (OS rel 0x012d02)
 PC was 0x007dc968 (OS rel 0x012d00)
 PC was 0x007dc964 (OS rel 0x012cfc)
 PC was 0x007dc962 (OS rel 0x012cfa)
 PC was 0x007dc95e (OS rel 0x012cf6)
 PC was 0x007e251a (OS rel 0x0188b2)
 PC was 0x007e2518 (OS rel 0x0188b0)
 PC was 0x007e2516 (OS rel 0x0188ae)
 PC was 0x007e2512 (OS rel 0x0188aa)
 PC was 0x007e250e (OS rel 0x0188a6)
 PC was 0x007e250c (OS rel 0x0188a4)
 PC was 0x007e2508 (OS rel 0x0188a0)
 PC was 0x007e2506 (OS rel 0x01889e)
 PC was 0x007e2504 (OS rel 0x01889c)
 PC was 0x007e2500 (OS rel 0x018898)
 PC was 0x007e24f6 (OS rel 0x01888e)
 PC was 0x007e24f2 (OS rel 0x01888a)

Der Mauspuffer kommt aus folgendem Befehl im Quelltext:

movea.l	mouse_buffer,a2

und im Disassembly:

 movea.l  $1964,a2

Der Zeiger auf den Puffer, also nicht der Puffer selbst wird definiert
in MXVDIKNL.S:

Hier ist wohl das Problem:

__a_vdi				EQU	$1200						;Anfang der VDI-Variablen
__e_vdi				EQU	SAVE_AREA_TT+8*16*4	;Ende der VDI-Variablen
SAVE_AREA_TT		EQU LINE_A_BASE+$0666	;long [8][16] TT-Hintergrundbuffer
LINE_A_BASE 		EQU MAGIX_110_BASE		;Adresslage von LINE-A
MAGIX_110_BASE 	EQU $2070					;MagiX 1.10
-> __e_vdi = $28d6

Und wo wird sust_len definiert?
Alles in MAGXBIOS.S. Es ergeben sich folgende Überlappungen (~60 Bytes Überlappung?):

Bconoutvec      liegt bei 0x11fe
                ...
                0x121a
do_gettime      liegt bei 0x121e
Mac_xfsx        bei 0x1220
warmbvec:           DS.L 1              /* Sprungadr. für Ctrl-Alt-Del     */
coldbvec:           DS.L 1              /* Sprungadr. für Ctrl-Alt-Rsh-Del */
sust_len:           DS.L 1              /* Supervisorstack pro Applikation */
datemode:           DS.W 1         ;für date2str (->STD.S)
log_fd:             DS.L 1              /* DateiHandle für Bootlog */
log_fd_pd:          DS.L 1              /* Prozeßdeskriptor für Handle */
log_oldconout:      DS.L 1              /* Alter Vektor für Bootlog */
p_vt52:             DS.L 1              /* für VT52.PRG */
__e_bios:

Die DOS-Variablen beginnen hart bei 0x2900 (__a_dos) und enden bei __e_dos. Das wird ausgerechnet.

Die öffentlichen BIOS-Variablen gehen von 0x380 bis einschließlich 0x5b0.
Die mit Adresse festgelegten BIOS-Variablen beginnen bei 0x840 und enden mit 0x9a4.
Ab 0x9a4 (clear_area) beginnen die allgemeinen BIOS-Variablen.
Man könnte den Bereich 0x5b4 bis 0x840 nutzen. 652 Bytes sollten reichen.




Absturz bei 4 Farben IP:

   exc = bus error (2)
    exception address = 0x21fc125c (?)
    AccessMode = read word
    pc = 0x007cf974 (OS ROM 0x00005d0c)
         code = 0x0028 [0x7214] 0x6100
    sr = 0x2008 (SUP NEG INT=0)
    usp = 0x00080000
     d0 = 0x21fcffff
     d1 = 0x000001bc
     d2 = 0x00000000
     d3 = 0x007c9e78
     d4 = 0x007cb456
     d5 = 0x007cb456
     d6 = 0x007cb456
     d7 = 0x00000000
     a0 = 0x007cb456
     a1 = 0x21fc1234
     a2 = 0x0000e480
     a3 = 0x007cb456
     a4 = 0x0000e4b4
     a5 = 0x007cb456
     a6 = 0x0000e466
     a7 = 0x0000e40a
    ProcPath = C:\AESSYS
    pd = 0x0001db64


Absturz bei 16 Farben IP:

exc = bus error (2)
    exception address = 0x21fc125c (?)
    AccessMode = read word
    pc = 0x007cf974
    sr = 0x2008 (SUP NEG INT=0)
    usp = 0x00080000
     d0 = 0x21fcffff
     d1 = 0x00029c1e
     d2 = 0x007cb456
     d3 = 0x007c9e78
     d4 = 0x007cb456
     d5 = 0x007cb456
     d6 = 0x007cb456
     d7 = 0x00000000
     a0 = 0x00000000
     a1 = 0x21fc1234
     a2 = 0x00029d1a
     a3 = 0x007cb456
     a4 = 0x0000e4b4
     a5 = 0x007cb456
     a6 = 0x0000e466
     a7 = 0x0000e40a
    ProcPath = C:\AESSYS
    pd = 0x0001e204

Bei PDkill() in MAGIDOS.S
 move.w   p_procid(a1),d0          ; pid
 p_parent(a5) ist


68k breakpoint reached
pc = 0x007cf95a (OS ROM 0x00005cf2)
   (sp) = 0x007d037c    OS ROM 0x6714, bei label pxc_mod102, XEXE_TERM, vom AES verwendet
  4(sp) = 0x007cb014
 d0 = 0x00000001
 d1 = 0x000001bc
 d2 = 0x00000000
 d3 = 0x007c9e78
 d4 = 0x007cb456
 d5 = 0x007cb456
 d6 = 0x007cb456
 d7 = 0x00000000
 a0 = 0x007cb456        <=== zeigt in den ROM-Code. Pampa
 a1 = 0x0000e466
 a2 = 0x0000e480
 a3 = 0x007cb456
 a4 = 0x0000e4b4
 a5 = 0x007cb456
 a6 = 0x0000e466
 a7 = 0x0000e438
 usp = 0x00080000

pc = 0x007cf95a (OS ROM 0x00005cf2)

pc = 0x007cf95e (OS ROM 0x00005cf6)
 a7 = 0x0000e42c

pc = 0x007cf960 (OS ROM 0x00005cf8)
 a7 = 0x0000e42a

pc = 0x007cf962 (OS ROM 0x00005cfa)

pc = 0x007cf964 (OS ROM 0x00005cfc)

pc = 0x007cf968 (OS ROM 0x00005d00)
 d0 = 0x00000000

pc = 0x007cf96c (OS ROM 0x00005d04)
 d0 = 0x21fc1234

pc = 0x007cf96e (OS ROM 0x00005d06)

pc = 0x007cf970 (OS ROM 0x00005d08)
 a1 = 0x21fc1234

(11:55:36) DBG-ERR m68k_read_memory_16(addr = 0x21fc125c) --- bus error (?) by process C:\AESSYS


The Atari memory size is given in bytes and excludes video memory which is handled separately.

Due to a bug in MVDI and NVDI, the VT52 emulator draws graphics artifacts e.g. with CLR SCREEN,
visible in the MagiC task manager or if VT52.PRG is missing, when the screen width and
height are not dividable by the system character size (8x8 or 8x16).

With no VT52.PRG, if starting MCMD, it takes forever until screen gets white,
here nine seconds. Why?

NVDI seems to freeze during start when ASSIGN.SYS is missing?



mcmd shows "0 bytes free"

Keep aspect ratio during window resize?

Emulator should check version of MAGICLIN.OS to make sure the API fits.

What is XHDI, and shall it be supported? It seems that DFS_FAT.S, the MagiC internal (V)FAT12/16/32
file system driver, supports this to get information about a storage volume.

system info control panel shows 29.12.2003 as kernel build date. Update!

Prevent volume image from being mounted twice.

Add command line option to convert Atari text files to UTF-8 and vice-versa, including line endings between CR/LF and LF.

Drag & Drop file systems treats every file as image. If one image is invalid, no further images can be mounted.
Maybe provide a list of supported file names extensions (.st, .image, .diskimage).

Atari/UTF-8 conversion is multiple times in the source code, for filenames and clipboard.


Create disk image:
- 512 bytes per sector
- 2 sectors per cluster
- FAT32
- verbose
- name "FAT32_1M"

dd if=/dev/zero of=vol-fat32-1M.img bs=1M count=1
mkfs.vfat -S 512 -s 2 -F 32 -v -n "FAT32_1M" vol-fat32-1M.img

GEMBENCH crashes (why?) and corrupts the whole emulated system. Why? Is there a deadlock in the emulator?

MGEDIT should be killable via MagiC task manager, but in most time this leads to a total system crash.

The MagiC message "System was overwritten" shall be passed to emulator.

Crash
01:04:39) DBG-ERR AtariGetKeyboardOrMouseData() --- Keine Daten
magic-on-linux: /home/and/Documents/magiclinux/src/HostHandles.cpp:136: void freeHostFD(HostFD*): Assertion `fd->ref_cnt > 0' failed.
Aborted (core dumped)
after copying "Techobox.CAD" to C:\ṪEMP and deleting target
Maybe recursive deleting of directory?


APPLICATIONS

To test:
- TWORD
- CAB
- Highwire
- Prolist (missing GDOS)

Works:

- Chagall v01.00
- Gempaint 1.3B2
- GSTFRAKT (single-app mode)
- MAPS (8+3 case-insensitive drive)
- Papillon 2.2
- Artworx v1.42 (complains about missing GDOS, needs case-insensitive drive)
- Cypress v1.50
- LDW Power Calc 1.03
- Papyrus 4 (complains about missing fonts, needs case-insensitive drive)
- Papyrus 7 (complains about missing fonts)
- Script (complains about missing fonts, needs case-insensitive drive)
- Script 2 (complains about missing fonts, needs case-insensitive drive)
- Technobox CAD/2 (needs case-insensitive drive)
- Texel 2.10
- Pure C
- RCS28K (patched by Andreas Kromke)
- Getinfo v1.1
- Prgflags
- Intrface v2.29beta
- Kobold?
- Olga?
- Pure Pascal: run in single mode (hold Alt key during start)




Works partially:

- CAMCAD (works at least in 640x400 monochrome, should run in single-application mode)
- DR Doodle (corrupts memory blocks, repairable)
- Logo (corrupts memory blocks, repairable)
- Easydraw (complains about missing GDOS)
- Scigraph (complains about missing GDOS)
- Font Expert, FONTEX.PRG (might run in single application mode)
- RSCTEXT (direct video memory acces, might work with 640x400)
- ST-Pascal (direct memory access, then bus error)

Works not:

- CAD 3D
- CAMPUS
- SWFŔAK.PRG (system was overwritten)
- PERSYS (draws artifacts like task manager in B/W)
- PLOT_IT.PRG (draws artifacts like task manager in B/W, then crashes)
- STAD_1_3.PRG (accesses video base register, needs case-insensitive drive, freezes system after crash)
- DBASE (why?)
- PHOENIX 4.2 (strange file selector recursion)     <<<=== needs debugging
- SIGNUM2 (trap #9 or memory mapped access to 68881)
- Wordplus (bus error. Why?)
- Wordplus 2 (bus error)
- SED_440

VDI drivers:

- *.OSD are offscreen drivers and not hardware related
-  *.NOD come from NVDI, they are faster than their OSD pendants.
   They are preferably loaded during boot process if they are found.
- MFA*.SYS are Atari hardware related and not used by MagicOnLinux or predecessors.
- MFM*.SYS are used by MagicOnLinux
-  NFM*.SYS come from NVDI, they are faster than their MFM pendants.
   They are not automatically loaded during boot, as the internal VDI
   explicitly opens e.g. MFM2.SYS in monochrome mode.
   It also seems that they are incompatible.

in particular:

- MFM2.SYS/NFM2.SYS: monochrome mode (black/white)
- MFM4IP.SYS:   4     colours in 2 interleaved planes
- MFM16.SYS:   16     colours in 4 consecutive (?) planes
- MFM16IP.SYS: 16     colours in 4 interlaved planes
- MFM16M.SYS:  16 mio colours, 32-bit pixel packed, 24 from which are used
- MFM32K.SYS:  32768  colours, 16-bit pixel packed
- MFM256.SYS:  256    colours, 8-bit pixel packed

Note that the 16M and 32K graphics formats are direct, i.e. no colour palettes.
All other modes are indirect, with a colour palette.

Note that 16M is recommended for MagicOnLinux. It is similar to the host
graphics format and thus leads to the best performance.
The IP formats are impractical for any kind of software and thus
are really slow.
